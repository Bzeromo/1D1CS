# ✅ Daily CS : CPU Scheduling Algorithm

>❓
> CPU Scheduling Algorithm,
> 종류별 장단점과 대표적인 사용 사례는?

***

## 🥇 FCFS (First-Come, First-Served)

🔷 **도착한 순서대로 처리**

-  단순하고 구현 쉬움


- 짧은 작업이 긴 작업 뒤에 밀릴 수 있음 → `Convoy effect`

***

## ⚡ SJF (Shortest Job First)

🔷 **실행 시간이 짧은 작업부터 실행**

- 이론적으로 평균 대기 시간 최소


- 실행 시간을 예측하기 어려움 → 실제 OS에서는 예측 기반 `SJF` 사용

***

## 🔄 Round Robin (RR)

🔷 **시간 할당량(`Time Quantum`) 만큼 순환하며 실행**

- 시분할 시스템에 적합


- 응답성 좋으나, 할당량 설정이 짧으면 오버헤드(`Overhead`), 길면 `FCFS`에 가까움

***

## 📊 Priority Scheduling

🔷 **우선순위 높은 작업부터 실행**


- 낮은 우선순위는 기아 현상(Starvation) 발생 가능 → Aging 기법으로 해결

***

## 🧺 Multilevel Queue Scheduling


🔷 **작업 성격에 따라 큐 분리 (ex. `Interactive`, `batch`)**

- 각 큐에 서로 다른 스케줄링 알고리즘 적용 가능

- 큐 간 전환 어려움 → `Multilevel Feedback Queue`로 보완

***

## ✅ 알고리즘 요약 비교표

| 알고리즘                 | 설명            | 장점           | 단점                      |
| -------------------- | ------------- | ------------ | ----------------------- |
| **FCFS**             | 도착 순서대로 실행    | 구현 쉬움        | 평균 대기 시간 ↑ (Convoy 현상)  |
| **SJF**              | 실행 시간 짧은 순    | 평균 대기 시간 ↓   | 실행 시간 예측 어려움            |
| **RR**               | 시간 할당량 단위로 순환 | 응답시간 ↓, 공정함  | 시간 할당량 선택이 민감           |
| **Priority**         | 우선순위 높은 순     | 중요 작업 우선 처리  | Starvation(기아 현상) 발생 가능 |
| **Multilevel Queue** | 작업 종류별 큐 나눔   | 다양한 정책 적용 가능 | 큐 간 전환 유연성 ↓            |

***

## 📝 실전 적용 예

| 시스템 유형                | 사용 스케줄링                   |
| --------------------- | ------------------------- |
| 일반 PC (Windows/Linux) | Multilevel Feedback Queue |
| 실시간 시스템               | Priority Scheduling       |
| 시분할 시스템               | Round Robin               |
| 배치 처리 시스템             | FCFS 또는 SJF               |

***

## 📕 용어 정리

📌 Convoy Effect(호위 효과)
: **CPU를 점유한 긴 작업이 끝날 때까지 짧은 작업들이 대기하며 전체 시스템 성능이 저하되는 현상**, <br>
`FCFS`(선입선출) 방식에서 자주 발생하며, 문맥 전환이 늦어지거나 `I/O` 장치가 놀게 되는 문제가 발생한다.

📌 시분할 시스템(Time-Sharing System)
: **여러 사용자가 하나의 시스템을 동시에 사용하는 것처럼 보이도록 CPU 시간을 분할하여 배분하는 시스템**, <br>
`Round Robin` 스케줄링이 대표적이며, 빠른 응답성과 공정한 자원 분배를 제공한다.

📌 오버헤드(Overhead)
: **시스템 자원을 직접적인 작업 처리 외의 부가적인 관리나 제어에 사용하는 비용**, <br>
예: 문맥 전환, 스레드 생성/소멸, 인터럽트 처리 등에서 발생하며, 성능 저하 요인이 될 수 있다.

📌 기아 현상(Starvation)
: **낮은 우선순위 작업이 자원을 장시간 할당받지 못해 무기한 대기하는 현상**, <br>
우선순위 기반 스케줄링에서 발생하며, 자원의 불공정한 분배로 인해 작업이 무시된다.

📌 에이징 기법(Aging)
: **기아 현상을 방지하기 위해 대기 시간이 길어질수록 프로세스의 우선순위를 점진적으로 높이는 기법**, <br>
시간이 지남에 따라 낮은 우선순위 작업도 결국 실행되도록 보장한다.

📌 인터랙티브, 대화형(Interactive)
: **사용자와의 직접적인 상호작용을 요구하는 작업 유형**, <br>
짧은 CPU 사용과 빠른 응답성을 요구하며, 주로 시분할 시스템에서 높은 우선순위를 갖는다. <br>
_예: 텍스트 에디터, 웹 브라우저_

📌 배치(Batch)
: **사용자의 직접 개입 없이 일괄적으로 실행되는 작업 유형**, <br>
처리 시간이 길고, CPU 사용량이 높지만 응답성 요구는 낮다. <br>
보통 백그라운드에서 실행되며 우선순위는 낮다. <br>
_예: 데이터 백업, 대규모 계산 작업_

📌 멀티레벨 피드백 큐(Multilevel Feedback Queue)
: **다단계 큐를 구성하여 작업의 실행 특성에 따라 동적으로 큐를 이동시키는 스케줄링 방식**, <br>
짧은 작업은 빠르게 처리하고, 긴 작업은 점점 낮은 우선순위로 보내며 공정성과 효율성을 동시에 추구한다. <br>
→ 시분할 + 우선순위 + 적응성까지 포함된 가장 복잡하지만 실용적인 방식